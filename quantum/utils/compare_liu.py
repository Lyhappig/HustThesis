from qiskit import *


def circuit_m1():
    # adder,f0~f3  g0~g3 aux(4 qbits)
    qc = QuantumCircuit(12)
    qc.ccx(0, 4, 8)
    qc.ccx(1, 5, 10)
    qc.ccx(2, 6, 11)
    qc.cx(8, 9)
    qc.cx(10, 8)
    qc.cx(0, 1)
    qc.cx(2, 3)
    qc.cx(4, 5)  # F_24multiplication       图6
    qc.cx(6, 7)
    qc.cx(11, 10)
    qc.cx(9, 11)
    qc.ccx(3, 7, 8)
    qc.ccx(1, 5, 11)
    qc.cx(3, 1)
    qc.cx(7, 5)
    qc.cx(11, 9)
    qc.cx(2, 3)
    qc.cx(6, 7)
    qc.cx(8, 9)
    qc.cx(0, 2)
    qc.cx(4, 6)
    qc.cx(9, 10)
    qc.ccx(3, 7, 8)
    qc.ccx(2, 6, 11)
    qc.cx(8, 10)
    qc.cx(11, 10)
    qc.ccx(1, 5, 11)
    qc.cx(2, 1)
    qc.cx(6, 5)
    qc.ccx(1, 5, 8)
    qc.cx(0, 2)
    qc.cx(4, 6)
    qc.cx(3, 1)
    qc.cx(7, 5)
    qc.barrier()
    return qc.depth()


def circuit_m2():
    # adder,f0~f3  g0~g3 aux(4 qbits)
    qc = QuantumCircuit(12)
    qc.cx(10, 9)
    qc.cx(11, 10)
    qc.cx(8, 11)
    qc.cx(9, 11)
    qc.cx(10, 11)
    qc.cx(10, 8)

    qc.ccx(0, 4, 8)
    qc.ccx(1, 5, 10)
    qc.ccx(2, 6, 11)
    qc.cx(8, 9)
    qc.cx(10, 8)
    qc.cx(0, 1)
    qc.cx(2, 3)
    qc.cx(4, 5)  # F_24multiplication       图7
    qc.cx(6, 7)
    qc.cx(11, 10)
    qc.cx(9, 11)
    qc.ccx(3, 7, 8)
    qc.ccx(1, 5, 11)
    qc.cx(3, 1)
    qc.cx(7, 5)
    qc.cx(11, 9)
    qc.cx(2, 3)
    qc.cx(6, 7)
    qc.cx(8, 9)
    qc.cx(0, 2)
    qc.cx(4, 6)
    qc.cx(9, 10)
    qc.ccx(3, 7, 8)
    qc.ccx(2, 6, 11)
    qc.cx(8, 10)
    qc.cx(11, 10)
    qc.ccx(1, 5, 11)
    qc.cx(2, 1)
    qc.cx(6, 5)
    qc.ccx(1, 5, 8)
    qc.cx(0, 2)
    qc.cx(4, 6)
    qc.cx(3, 1)
    qc.cx(7, 5)
    return qc.depth()


def circuit_lambda():
    # m -> m^2 * lambda   Fig.14
    qc = QuantumCircuit(4)
    qc.cx(2, 3)
    qc.cx(1, 2)
    qc.cx(3, 1)
    qc.cx(3, 0)
    qc.swap(0, 2)
    qc.swap(1, 3)
    return qc.depth()


def circuit_I():
    # x0~3, aux(1 qbits)   F_24 multiplicative inversion
    qc = QuantumCircuit(5)
    qc.cx(1, 2)
    qc.cx(0, 1)
    qc.ccx(2, 3, 0)
    qc.ccx(0, 1, 3)
    qc.cx(3, 1)
    qc.cx(2, 0)  # F_24inv  图9
    qc.cx(0, 3)
    qc.ccx(3, 2, 4)
    qc.ccx(4, 1, 0)
    qc.ccx(3, 2, 4)
    qc.ccx(4, 1, 0)
    qc.ccx(0, 3, 2)
    qc.ccx(1, 2, 3)
    qc.cx(3, 1)
    qc.cx(3, 0)
    qc.swap(2, 3)
    qc.swap(1, 2)
    return qc.depth()


def circuit_M():  # xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    qc = QuantumCircuit(8)
    qc.cx(1, 4)
    qc.cx(5, 3)
    qc.cx(2, 1)
    qc.cx(6, 0)
    qc.cx(0, 1)
    qc.cx(7, 0)
    qc.cx(2, 7)
    qc.cx(6, 7)
    qc.cx(4, 5)
    qc.cx(4, 2)  # MA(x)+Mc   图5
    qc.cx(4, 0)
    qc.cx(3, 0)

    qc.swap(6, 5)
    qc.swap(4, 3)
    qc.swap(2, 1)
    qc.swap(6, 0)
    qc.swap(1, 0)

    qc.x(5)
    qc.x(4)
    qc.x(3)
    qc.x(2)

    qc.barrier(range(7))
    return qc.depth()


def circuit_A_Minverse():  # xxxxxxxxxxxxxxxxxxxxxxxx
    # A*M^(-1)+c
    qc = QuantumCircuit(8)
    qc.cx(2, 3)
    qc.cx(6, 7)
    qc.cx(3, 1)
    qc.cx(0, 6)
    qc.cx(2, 0)
    qc.cx(4, 2)
    qc.cx(5, 3)
    qc.cx(3, 7)
    qc.cx(7, 2)  # AM^(-1)(x) +c      图4
    qc.cx(0, 5)
    qc.cx(6, 1)
    qc.cx(2, 6)
    qc.cx(2, 5)
    qc.cx(1, 4)

    qc.swap(7, 6)
    qc.swap(1, 4)
    qc.swap(6, 5)
    qc.swap(4, 3)

    return qc.depth()


def circuit_K1():  # xxxxxxxxxxxxxxxxxxxxxxxx
    # K1
    qc = QuantumCircuit(9)
    qc.cx(2, 3)
    qc.cx(1, 4)
    qc.cx(2, 4)
    qc.cx(5, 6)
    qc.cx(0, 6)
    qc.cx(1, 7)
    qc.cx(3, 7)
    qc.cx(4, 5)
    qc.cx(3, 5)
    qc.cx(2, 3)
    qc.ccx(6, 7, 4)
    qc.ccx(4, 5, 7)
    qc.cx(7, 5)
    qc.cx(6, 4)  # 图12
    qc.cx(4, 7)
    qc.ccx(7, 6, 8)
    qc.ccx(8, 5, 4)
    qc.ccx(7, 6, 8)
    qc.ccx(8, 5, 4)
    qc.ccx(4, 7, 6)
    qc.ccx(5, 6, 7)
    qc.cx(7, 5)
    qc.cx(7, 4)
    qc.swap(6, 7)
    qc.swap(5, 6)

    return qc.depth()


def circuit_K2():  # xxxxxxxxxxxxxxxxxxxxxxxx
    # K2
    qc = QuantumCircuit(9)
    qc.cx(5, 6)
    qc.cx(4, 5)
    qc.ccx(6, 7, 4)
    qc.ccx(4, 5, 7)
    qc.cx(7, 5)
    qc.cx(6, 4)  # 图13
    qc.cx(4, 7)
    qc.ccx(7, 6, 8)
    qc.ccx(8, 5, 4)
    qc.ccx(7, 6, 8)
    qc.ccx(8, 5, 4)
    qc.ccx(4, 7, 6)
    qc.ccx(5, 6, 7)
    qc.cx(2, 3)
    qc.cx(3, 7)
    qc.cx(7, 5)
    qc.cx(0, 5)
    qc.cx(3, 6)
    qc.cx(1, 6)
    qc.cx(2, 3)
    qc.cx(7, 4)
    qc.cx(3, 4)
    qc.cx(1, 4)
    qc.swap(6, 7)
    qc.swap(5, 6)

    return qc.depth()


if __name__ == '__main__':
    print("m1 depth:", circuit_m1())
    print("m2 depth:", circuit_m2())
    print("I depth:", circuit_I())
    print("M depth:", circuit_M())
    print("A_Minverse depth:", circuit_A_Minverse())
    print("K1 depth:", circuit_K1())
    print("K2 depth:", circuit_K2())
